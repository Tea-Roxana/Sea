from tkinter import *
from tkinter import messagebox
import random 


def generate_ai_ships():
    board = [[0 for _ in range(10)] for _ in range(10)]
    ai_ships = [4, 3, 3, 2, 2, 2, 1, 1, 1, 1]  #размеры кораблей
    
    for ship_size in ai_ships:
        placed = False
        attempts = 0
        
        while not placed and attempts < 100:
            direction = random.choice(['г', 'в'])
            if direction == 'г':  #горизонтально
                max_x = 10
                max_y = 10 - ship_size + 1
            else:  #вертикально
                max_x = 10 - ship_size + 1
                max_y = 10
            
            start_x = random.randint(0, max_x - 1)
            start_y = random.randint(0, max_y - 1)
            
            can_place = True
            for i in range(ship_size):
                if direction == 'г':
                    x = start_x
                    y = start_y + i
                else:
                    x = start_x + i
                    y = start_y
                    
                if not (0 <= x < 10 and 0 <= y < 10):
                    can_place = False
                    break
                    
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < 10 and 0 <= ny < 10:
                            if board[nx][ny] == 1:
                                can_place = False
                                break
                    if not can_place:break
                if not can_place:break
           
            if can_place:
                for i in range(ship_size):
                    if direction == 'г':
                        x = start_x
                        y = start_y + i
                    else:
                        x = start_x + i
                        y = start_y
                    board[x][y] = 1
                placed = True
            attempts += 1
        
        if not placed:return generate_ai_ships()
    return board


def place_ships():
    rules = [(1, 4), (2, 3), (3, 2), (4, 1)]
    entries = {4: [], 3: [],  2: [], 1: []}
    n_page = Toplevel()
    n_page.title("Расстановка кораблей")
    Label(n_page, text="Впишите координаты начала (х1 у1) и направление (г или в). Например: а 1 в").grid(row=0, column=0, columnspan=3, pady=10)    
    row = 1
    for count, size in rules:
        Label(n_page, text=f"{size}-палубный", font=("Arial", 10, "bold")).grid(row=row, column=0, sticky="w", padx=10)
        row += 1
        for i in range(count):            
            Label(n_page, text="Координаты:").grid(row=row, column=0, sticky="w", padx=20)
            entry_ship = Entry(n_page, width=15)
            entry_ship.grid(row=row, column=1, padx=5, pady=2, sticky="we")
            entries[size].append(entry_ship)
            row += 1
    
    Button(n_page, text="Разместить корабли", command=lambda: save_ships(entries, n_page)).grid(row=row, column=0, columnspan=2, pady=20)
    n_page.columnconfigure(1, weight=1)
    n_page.grab_set()  #пока не закрою окно, не смогу взаимодействовать с главным


def save_ships(entries, n_page):
    global board_p, board_ai, letters
    board_numeric = [[0]*10 for _ in range(10)]

    for i in range(10):
        for j in range(10):
            board_numeric[i][j] = board_p[i][j]
    
    existing_ships_info = get_ships_detailed(board_numeric)
    ships_to_place = []
    for size, entry_list in entries.items():
        for entry in entry_list:
            coordinates = entry.get().strip()
            if coordinates: 
                coords_list = coordinates.split()
                try:
                    if len(coords_list) >= 3:
                        start_x = letters.index(coords_list[0].upper()) 
                        start_y = int(coords_list[1]) - 1
                        direction = coords_list[2].lower()
                        
                        if not (0 <= start_x < 10 and 0 <= start_y < 10):  continue
                              
                        ships_to_place.append({
                            'size': size,
                            'start_x': start_x,
                            'start_y': start_y, 
                            'direction': direction
                        })
                except ValueError:continue
    removed_cells = set()  #отслеживаем удаленные клетки
    
    for ship in ships_to_place:
        size = ship['size']
        start_x = ship['start_x']
        start_y = ship['start_y']
        
        if size == 1:
            if board_numeric[start_x][start_y] == 1:
                board_numeric[start_x][start_y] = 0
                removed_cells.add((start_x, start_y))
        else:
            ship_to_remove = None
            for existing_ship in existing_ships_info:
                if existing_ship['size'] == size:
                    cells_still_exist = any(board_numeric[x][y] == 1 for x, y in existing_ship['cells'])
                    if cells_still_exist:
                        ship_to_remove = existing_ship
                        break
            
            #удаление найденного корабля
            if ship_to_remove:
                for x, y in ship_to_remove['cells']:
                    board_numeric[x][y] = 0
                    removed_cells.add((x, y))
                existing_ships_info.remove(ship_to_remove)
    for ship in ships_to_place:
        size = ship['size']
        start_x = ship['start_x']
        start_y = ship['start_y']
        direction = ship['direction']
        
        can_place = True
        for i in range(size):
            if direction == 'г':
                x = start_x
                y = start_y + i
            else:
                x = start_x + i
                y = start_y
            
            if not (0 <= x < 10 and 0 <= y < 10):
                can_place = False
                break
                
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < 10 and 0 <= ny < 10:
                        if board_numeric[nx][ny] == 1:
                            can_place = False
                            break
                if not can_place:break
            if not can_place: break
        
        if can_place:
            for i in range(size):
                if direction == 'г':
                    x = start_x
                    y = start_y + i
                else:
                    x = start_x + i
                    y = start_y
                board_numeric[x][y] = 1

    if check_placement_partial(board_numeric):
        board_p = board_numeric
        for i in range(10):
            for j in range(10):
                if board_numeric[i][j] == 1:buttons_p[i][j].config(bg='#639799')
                else: buttons_p[i][j].config(bg='light blue')        
        board_ai = generate_ai_ships()
        n_page.grab_release() 
        n_page.destroy()
        return True
    else:
        messagebox.showerror("Ошибка", "Некорректная расстановка кораблей!")
        return False

def get_ships_detailed(board):
    temp_board = [row[:] for row in board]
    ships_info = []
    visited = set()
    
    for i in range(10):
        for j in range(10):
            if temp_board[i][j] == 1 and (i, j) not in visited:
                ship_cells = []
                stack = [(i, j)]
                
                while stack:
                    x, y = stack.pop()
                    if (x, y) not in visited and temp_board[x][y] == 1:
                        visited.add((x, y))
                        ship_cells.append((x, y))
                        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < 10 and 0 <= ny < 10:stack.append((nx, ny))
                if ship_cells:
                    ships_info.append({
                        'size': len(ship_cells),
                        'cells': ship_cells,
                        'start': (i, j)
                    })
    return ships_info

def do_ships_overlap(existing_ship, new_start_x, new_start_y, new_size, new_direction):
    new_cells = []
    for i in range(new_size):
        if new_direction == 'г':
            x = new_start_x
            y = new_start_y + i
        else:
            x = new_start_x + i
            y = new_start_y
        new_cells.append((x, y))
    
    for existing_cell in existing_ship['cells']:
        if existing_cell in new_cells:return True
    
    return False


def find_existing_ships(board):
    temp_board = [row[:] for row in board]
    ships_sizes = []
    visited = set()
    
    for i in range(10):
        for j in range(10):
            if temp_board[i][j] == 1 and (i, j) not in visited:
                ship_cells = []
                stack = [(i, j)]
                
                while stack:
                    x, y = stack.pop()
                    if (x, y) not in visited and temp_board[x][y] == 1:
                        visited.add((x, y))
                        ship_cells.append((x, y))
                        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < 10 and 0 <= ny < 10:stack.append((nx, ny))
                if ship_cells:ships_sizes.append(len(ship_cells))
    return ships_sizes

def remove_ship_of_size(board, target_size):
    temp_board = [row[:] for row in board]
    visited = set()
    
    for i in range(10):
        for j in range(10):
            if temp_board[i][j] == 1 and (i, j) not in visited:
                ship_cells = []
                stack = [(i, j)]
                
                while stack:
                    x, y = stack.pop()
                    if (x, y) not in visited and temp_board[x][y] == 1:
                        visited.add((x, y))
                        ship_cells.append((x, y))
                        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < 10 and 0 <= ny < 10:stack.append((nx, ny))
                
                if len(ship_cells) == target_size:
                    for x, y in ship_cells:
                        board[x][y] = 0
                    return True
    return False

def check_placement_partial(board):
    temp_board = [row[:] for row in board]
    for i in range(10):
        for j in range(10):
            if temp_board[i][j] == 1:
                for dx, dy in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                    nx, ny = i + dx, j + dy
                    if 0 <= nx < 10 and 0 <= ny < 10:
                        if temp_board[nx][ny] == 1: return False
    
    visited = set()
    for i in range(10):
        for j in range(10):
            if temp_board[i][j] == 1 and (i, j) not in visited:
                ship_cells = []
                stack = [(i, j)]
                while stack:
                    x, y = stack.pop()
                    if (x, y) not in visited and temp_board[x][y] == 1:
                        visited.add((x, y))
                        ship_cells.append((x, y))
                        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < 10 and 0 <= ny < 10:
                                stack.append((nx, ny))
                                
                if len(ship_cells) > 1:
                    rows = set(x for x, y in ship_cells)
                    cols = set(y for x, y in ship_cells)
                    if len(rows) > 1 and len(cols) > 1:return False
                if len(ship_cells) > 4:return False
                    
    return True

def ai_move():
    global ai_possible_moves, last_hit

    if last_hit:
        direction = None
        if len(last_hit) > 1:
            row1, col1 = last_hit[0]
            row2, col2 = last_hit[1]
            if row1 == row2:  #одинаковые строки - г
                direction = 'г'
            elif col1 == col2:  #одинаковые столбцы - в
                direction = 'в'
        
        last_hit_element = last_hit[-1]
        row, col = last_hit_element[0], last_hit_element[1]
        
        if direction == 'г':
            targets = [(row, col-1), (row, col+1)]  #только влево/вправо
        elif direction == 'в':
            targets = [(row-1, col), (row+1, col)]  #только вверх/вниз
        else:
            targets = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]
        
        for r, c in targets:
            if 0 <= r < 10 and 0 <= c < 10 and (r, c) in ai_possible_moves:
                ai_possible_moves.remove((r, c))
                return [r, c]
        
        for hit in last_hit[:-1]:
            row, col = hit[0], hit[1]
            targets = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]
            for r, c in targets:
                if 0 <= r < 10 and 0 <= c < 10 and (r, c) in ai_possible_moves:
                    ai_possible_moves.remove((r, c))
                    return [r, c]

    if ships.count(4) != 0:
        for _ in range(10):  # поиск 4-палубника
            side = random.choice([1, 2])
            line = random.choice([4, 8])
            if side == 1:
                fire = random.randint(0, line-1)
                row, col = line-fire-1, fire
            else:
                fire = random.randint(0, line-1)
                row, col = 9 - (line - fire) + 1, 9-fire
            if 0 <= row < 10 and 0 <= col < 10 and (row, col) in ai_possible_moves:
                ai_possible_moves.remove((row, col))
                return [row, col]
                
    if ships.count(3) != 0:
        for _ in range(10):  # поиск 3-палубника
            side = random.choice([1, 2])
            if side == 1:
                line = random.choice([3, 6, 9])
                fire = random.randint(0, line-1)
                row, col = line-fire-1, fire
            else:
                line = random.choice([2, 5, 8])
                fire = random.randint(0, line-1)
                row, col = 9 - (line - fire) + 1, 9-fire
            if 0 <= row < 10 and 0 <= col < 10 and (row, col) in ai_possible_moves:
                ai_possible_moves.remove((row, col))
                return [row, col]
                
    if ships.count(2) != 0:
        for _ in range(10):  # поиск 2-палубника
            side = random.choice([1, 2])
            line = random.choice([2, 4, 6, 8])
            if side == 1:
                fire = random.randint(0, line-1)
                row, col = line-fire-1, fire
            else:
                fire = random.randint(0, line-1)
                row, col = 9 - (line - fire) + 1, 9-fire
            if 0 <= row < 10 and 0 <= col < 10 and (row, col) in ai_possible_moves:
                ai_possible_moves.remove((row, col))
                return [row, col]

    if ai_possible_moves:
        move = random.choice(ai_possible_moves)
        ai_possible_moves.remove(move)
        return list(move)
    return [0, 0]

def remove_hits(ship_hits, board, buttons, player_turn):
    global ai_possible_moves, ships, player_ships

    if not ship_hits:return False    
    ship_destroyed = True

    for hit in ship_hits:  
        row, col = hit[0], hit[1]
        neighbors = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)] 
        for r, c in neighbors:
            if 0 <= r < 10 and 0 <= c < 10:
                if board[r][c] == 1:
                    ship_destroyed = False
                    break
        if not ship_destroyed:break
            
    if ship_destroyed:
        cells_to_mark = set()
        if player_turn == "ai":
            if len(ship_hits) in ships:
                ships.remove(len(ship_hits))
        else:
            if len(ship_hits) in player_ships:
                player_ships.remove(len(ship_hits))
            
        for hit in ship_hits:
            row, col = hit[0], hit[1]
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    r, c = row + dr, col + dc
                   
                    if 0 <= r < 10 and 0 <= c < 10 and board[r][c] == 0:
                        cells_to_mark.add((r, c))

        for r, c in cells_to_mark:
            board[r][c] = -1
            if player_turn == "player":
                buttons[r][c].config(bg='white', text='•')
                player_moves.append((r, c))
            else:
                buttons[r][c].config(bg='light gray', text='•')
                if (r, c) in ai_possible_moves:
                    ai_possible_moves.remove((r, c))
        
        return True
    return False


def check_winner(turn):
    global ships, player_ships
    if turn == "player":
        ai_ships_remaining = any(cell == 1 for row in board_ai for cell in row)
        if not ai_ships_remaining:
            messagebox.showinfo("Конец игры", "Победил Игрок!") 
            if messagebox.askyesno("Новая игра", "Начать заново?"):restart()
            return True
            
    elif turn == "ai":
        player_ships_remaining = any(cell == 1 for row in board_p for cell in row)
        if not player_ships_remaining:
            messagebox.showinfo("Конец игры", "Победил Компьютер!")
            if messagebox.askyesno("Новая игра", "Начать заново?"): restart()
            return True
    return False


def restart():
    global ships, player_ships, buttons_p, buttons_ai, board_p, board_ai
    global player_turn, ai_possible_moves, player_moves, last_hit, last_hit_player
    ships, player_ships = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4], [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
    buttons_p, buttons_ai = [], []
    board_p, board_ai = [[0]*10 for i in range(10)], [[0]*10 for i in range(10)]
    player_turn = "player"
    ai_possible_moves = [(r, c) for r in range(10) for c in range(10)]
    player_moves = []  
    last_hit, last_hit_player = [], []
    for widget in board.winfo_children():
        widget.destroy()
    set_board()
    

def make_move(row, col):
    global player_turn, last_hit, last_hit_player, player_moves
    if not ships or not player_ships:return
        
    if player_turn == "player":
        if (row, col) in player_moves:
            return  #уже ходили сюда
        if board_ai[row][col] == 1:  #попали
            buttons_ai[row][col].config(bg='red', text='X')
            board_ai[row][col] = 2
            last_hit_player.append([row, col])
            if remove_hits(last_hit_player, board_ai, buttons_ai, player_turn):
                last_hit_player = []
            player_moves.append((row, col))
            check_winner("player")
            return
            
        else:  #промах
            buttons_ai[row][col].config(bg='white', text='•')
            board_ai[row][col] = -1
            player_turn = "ai"
            player_moves.append((row, col))

    if player_turn == "ai":
        ai_hit = True
        while ai_hit and player_turn == "ai":
            fire = ai_move()
            row_ai, col_ai = fire[0], fire[1]
            if board_p[row_ai][col_ai] == 1:  #попали
                buttons_p[row_ai][col_ai].config(bg='red', text='X')
                board_p[row_ai][col_ai] = 2
                last_hit.append([row_ai, col_ai])
                if remove_hits(last_hit, board_p, buttons_p, "ai"):
                    last_hit = []
                ai_hit = True
                check_winner("ai")
                
            else:  #промах
                buttons_p[row_ai][col_ai].config(bg='white', text='•')
                board_p[row_ai][col_ai] = -1
                player_turn = "player"  
                ai_hit = False


def set_board():
    for row in range(10):    
        row_buttons_p = []
        row_buttons_ai = []
        for col in range(10):
            btn_p = Button(board, text=" ", width=2, height=1, bg="light blue")
            btn_p.grid(row=row, column=col, padx=1, pady=1)
            row_buttons_p.append(btn_p)
            btn_ai = Button(board, text=" ", width=2, height=1, command=lambda r=row, c=col: make_move(r, c), bg="light grey")
            btn_ai.grid(row=row, column=col+11, padx=1, pady=1)
            row_buttons_ai.append(btn_ai)
        if col + 1 == 10:
            Label(board, text=letters[row], font=("Arial", 10, "bold")).grid(row=row, column=col+1, padx=1, pady=1)
        buttons_p.append(row_buttons_p)
        buttons_ai.append(row_buttons_ai)

root = Tk()
root.title("Морской бой")

lable = Label(root, text="Морской бой", font=("Arial", 14))
lable.pack(pady=10, anchor="center")

numbers_frame = Frame(root)
numbers_frame.pack(padx=5, pady=(0, 5))

for col in range(10):
    Label(numbers_frame, text=str(col+1), font=("Arial", 10, "bold"), width=2).grid(row=0, column=col, padx=2)
    Label(numbers_frame, text="", width=2).grid(row=0, column=10)
    Label(numbers_frame, text=str(col+1), font=("Arial", 10, "bold"), width=2).grid(row=0, column=col+11, padx=2)

board = Frame(root)
board.pack(padx=10, pady=10, anchor="e")

letters = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'К']
ships, player_ships = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4], [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
buttons_p, buttons_ai = [], []
board_p, board_ai = [[0]*10 for i in range(10)], [[0]*10 for i in range(10)]
player_turn = "player"
ai_possible_moves, player_moves  = [(r, c) for r in range(10) for c in range(10)], []
last_hit, last_hit_player = [], []

set_board()

btn_ship = Button(root, text="Разместить корабли", font=("Arial", 10), command=place_ships)
btn_ship.pack(padx=10, pady=20, anchor="e")       

root.mainloop()

